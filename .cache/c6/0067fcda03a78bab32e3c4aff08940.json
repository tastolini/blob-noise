{"id":"d6V5","dependencies":[{"name":"/Users/adriancaluseriu/Documents/GitHub/blob-noise/package.json","includedInParent":true,"mtime":1675074860878}],"generated":{"js":"module.exports=\"#define GLSLIFY 1\\n//\\tSimplex 4D Noise \\n//\\tby Ian McEwan, Ashima Arts\\n//\\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\\n\\nvec4 grad4(float j, vec4 ip){\\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\\n  vec4 p,s;\\n\\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\\n  s = vec4(lessThan(p, vec4(0.0)));\\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \\n\\n  return p;\\n}\\n\\nfloat snoise(vec4 v){\\n  const vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4\\n                        0.309016994374947451); // (sqrt(5) - 1)/4   F4\\n// First corner\\n  vec4 i  = floor(v + dot(v, C.yyyy) );\\n  vec4 x0 = v -   i + dot(i, C.xxxx);\\n\\n// Other corners\\n\\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\\n  vec4 i0;\\n\\n  vec3 isX = step( x0.yzw, x0.xxx );\\n  vec3 isYZ = step( x0.zww, x0.yyz );\\n//  i0.x = dot( isX, vec3( 1.0 ) );\\n  i0.x = isX.x + isX.y + isX.z;\\n  i0.yzw = 1.0 - isX;\\n\\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\\n  i0.y += isYZ.x + isYZ.y;\\n  i0.zw += 1.0 - isYZ.xy;\\n\\n  i0.z += isYZ.z;\\n  i0.w += 1.0 - isYZ.z;\\n\\n  // i0 now contains the unique values 0,1,2,3 in each channel\\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\\n\\n  //  x0 = x0 - 0.0 + 0.0 * C \\n  vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\\n  vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\\n  vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\\n  vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\\n\\n// Permutations\\n  i = mod(i, 289.0); \\n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\\n  vec4 j1 = permute( permute( permute( permute (\\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\\n// Gradients\\n// ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)\\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\\n\\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\\n\\n  vec4 p0 = grad4(j0,   ip);\\n  vec4 p1 = grad4(j1.x, ip);\\n  vec4 p2 = grad4(j1.y, ip);\\n  vec4 p3 = grad4(j1.z, ip);\\n  vec4 p4 = grad4(j1.w, ip);\\n\\n// Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n  p4 *= taylorInvSqrt(dot(p4,p4));\\n\\n// Mix contributions from the five corners\\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\\n  m0 = m0 * m0;\\n  m1 = m1 * m1;\\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\\n\\n}\";"},"sourceMaps":{"js":{"mappings":[{"source":"src/shaders/noise.glsl","name":"module","original":{"line":1,"column":0},"generated":{"line":1,"column":0}},{"source":"src/shaders/noise.glsl","name":"exports","original":{"line":1,"column":7},"generated":{"line":1,"column":7}},{"source":"src/shaders/noise.glsl","original":{"line":1,"column":15},"generated":{"line":1,"column":15}}],"sources":{"src/shaders/noise.glsl":"module.exports=\"#define GLSLIFY 1\\n//\\tSimplex 4D Noise \\n//\\tby Ian McEwan, Ashima Arts\\n//\\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\\n\\nvec4 grad4(float j, vec4 ip){\\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\\n  vec4 p,s;\\n\\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\\n  s = vec4(lessThan(p, vec4(0.0)));\\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \\n\\n  return p;\\n}\\n\\nfloat snoise(vec4 v){\\n  const vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4\\n                        0.309016994374947451); // (sqrt(5) - 1)/4   F4\\n// First corner\\n  vec4 i  = floor(v + dot(v, C.yyyy) );\\n  vec4 x0 = v -   i + dot(i, C.xxxx);\\n\\n// Other corners\\n\\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\\n  vec4 i0;\\n\\n  vec3 isX = step( x0.yzw, x0.xxx );\\n  vec3 isYZ = step( x0.zww, x0.yyz );\\n//  i0.x = dot( isX, vec3( 1.0 ) );\\n  i0.x = isX.x + isX.y + isX.z;\\n  i0.yzw = 1.0 - isX;\\n\\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\\n  i0.y += isYZ.x + isYZ.y;\\n  i0.zw += 1.0 - isYZ.xy;\\n\\n  i0.z += isYZ.z;\\n  i0.w += 1.0 - isYZ.z;\\n\\n  // i0 now contains the unique values 0,1,2,3 in each channel\\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\\n\\n  //  x0 = x0 - 0.0 + 0.0 * C \\n  vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\\n  vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\\n  vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\\n  vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\\n\\n// Permutations\\n  i = mod(i, 289.0); \\n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\\n  vec4 j1 = permute( permute( permute( permute (\\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\\n// Gradients\\n// ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)\\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\\n\\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\\n\\n  vec4 p0 = grad4(j0,   ip);\\n  vec4 p1 = grad4(j1.x, ip);\\n  vec4 p2 = grad4(j1.y, ip);\\n  vec4 p3 = grad4(j1.z, ip);\\n  vec4 p4 = grad4(j1.w, ip);\\n\\n// Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n  p4 *= taylorInvSqrt(dot(p4,p4));\\n\\n// Mix contributions from the five corners\\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\\n  m0 = m0 * m0;\\n  m1 = m1 * m1;\\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\\n\\n}\";"},"lineCount":null}},"error":null,"hash":"0f127a4198ad2714093abf8b6731c07c","cacheData":{"env":{}}}